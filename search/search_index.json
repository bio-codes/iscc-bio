{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#iscc-bio-iscc-processing-for-bioimage-data","title":"iscc-bio - ISCC Processing for Bioimage Data","text":"<p>ISCC Processing for Multi-Dimensional Bioimage Data</p> <p>Generate ISO 24138:2024 International Standard Content Codes (ISCC) for bioimage data across multiple formats using deterministic IMAGEWALK plane traversal.</p>"},{"location":"#project-status","title":"Project Status","text":"<p>Version 0.1.0 - Unreleased.</p> <p>Warning</p> <p>This package is a proof of concept under active development, and breaking changes may be released at any time.</p>"},{"location":"#overview","title":"Overview","text":"<p><code>iscc-bio</code> bridges bioimage formats with ISCC-CODE processing by implementing the IMAGEWALK specification - a deterministic algorithm for traversing and canonicalizing pixel data from multi-dimensional bioimaging data. This produces consistent, reproducible content identifiers regardless of source format or storage platform.</p> <p>Documentation: https://bio.iscc.codes</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Format-Agnostic Hashing: Generate reproducible ISCCs at the level of pixel data across OME-TIFF, OME-Zarr,     OMERO, CZI, ND2, LIF, and other formats</li> <li>IMAGEWALK Implementation: Deterministic Z\u2192C\u2192T plane traversal with canonical byte representation</li> <li>Multi-Source Support: Process local files (via BioIO), OME-Zarr archives, and OMERO remote servers</li> <li>Memory Efficient: Lazy loading with Dask for processing large multi-dimensional images</li> <li>Multi-Scene Processing: Handle complex multi-scene/multi-series bioimage files</li> <li>Command-Line Tools: CLI commands for code generation, pixel hashing, and view extraction</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#basic-installation","title":"Basic Installation","text":"<pre><code># Using uv (recommended)\nuv tool install iscc-bio\n\n# Using pip\npip install iscc-bio\n</code></pre>"},{"location":"#installation-with-format-support","title":"Installation with Format Support","text":"<pre><code># Install with all bioimage reader plugins\nuv tool install \"iscc-bio[readers]\"\n\n# Install with specific format support\nuv tool install \"iscc-bio[czi,nd2,lif]\"\n\n# Install with OMERO support\nuv tool install \"iscc-bio[omero]\"\n\n# Install everything\nuv tool install \"iscc-bio[all]\"\n</code></pre>"},{"location":"#available-optional-dependencies","title":"Available Optional Dependencies","text":"<ul> <li>readers: All BioIO reader plugins (BioFormats, CZI, OME-TIFF, OME-Zarr, ND2, LIF, etc.)</li> <li>omero: OMERO Blitz gateway for remote server access</li> <li>bioformats: BioFormats reader for broad format support</li> <li>czi, nd2, lif, ome-tiff, ome-zarr-plugin, dv, tifffile: Individual format readers</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#eperimantal-cli-scripts","title":"Eperimantal CLI scripts","text":""},{"location":"#generate-bioimage-fingerprint","title":"Generate Bioimage Fingerprint","text":"<pre><code># Generate ISCC-based bioimage fingerprint\niscc-bio biocode myimage.czi\n\n# Output includes:\n# - ISCC-SUM hash over normalized pixel content\n# - Representative view extraction (~5 views per scene)\n# - ISCC-IMAGE codes for each view\n# - ISCC-MIXED global descriptor\n</code></pre>"},{"location":"#pixel-hash-imagewalk","title":"Pixel Hash (IMAGEWALK)","text":"<pre><code># Generate reproducible pixel hash using IMAGEWALK\niscc-bio pixhash myimage.ome.tiff\n\n# Works with multiple sources:\niscc-bio pixhash local/file.czi           # Local bioimage file\niscc-bio pixhash data.zarr                # OME-Zarr/NGFF\niscc-bio pixhash --host omero.server.com --iid 123  # OMERO server\n</code></pre>"},{"location":"#extract-representative-views","title":"Extract Representative Views","text":"<pre><code># Extract intelligent 2D views for perceptual hashing\niscc-bio views myimage.nd2 --output-dir ./views/\n\n# Extraction strategies:\n# - Maximum intensity projections (MIP)\n# - Best focus planes\n# - Representative sampling\n# - Multi-channel composites\n</code></pre>"},{"location":"#imagewalk-specification","title":"IMAGEWALK Specification","text":"<p>IMAGEWALK is a deterministic algorithm for traversing multi-dimensional bioimage data to produce format-agnostic, reproducible hash digests.</p>"},{"location":"#core-principles","title":"Core Principles","text":"<ol> <li> <p>Z\u2192C\u2192T Traversal Order: Planes are processed in deterministic order:</p> <ul> <li>Outermost loop: Z dimension (depth/focal plane)</li> <li>Middle loop: C dimension (channel)</li> <li>Innermost loop: T dimension (time)</li> </ul> </li> <li> <p>Canonical Byte Representation: Each 2D plane is:</p> <ul> <li>Flattened in row-major order (Y then X)</li> <li>Encoded as big-endian bytes</li> <li>Fed to a hash processor</li> </ul> </li> <li> <p>Multi-Scene Independence: Each scene/series is processed separately, producing one hash per scene</p> </li> </ol>"},{"location":"#example-traversal","title":"Example Traversal","text":"<p>For an image with <code>Z=2, C=3, T=2</code> dimensions (12 total planes):</p> <pre><code>Plane 1:  z=0, c=0, t=0    Plane 7:  z=1, c=0, t=0\nPlane 2:  z=0, c=0, t=1    Plane 8:  z=1, c=0, t=1\nPlane 3:  z=0, c=1, t=0    Plane 9:  z=1, c=1, t=0\nPlane 4:  z=0, c=1, t=1    Plane 10: z=1, c=1, t=1\nPlane 5:  z=0, c=2, t=0    Plane 11: z=1, c=2, t=0\nPlane 6:  z=0, c=2, t=1    Plane 12: z=1, c=2, t=1\n</code></pre>"},{"location":"#implementation-modules","title":"Implementation Modules","text":"<ul> <li><code>iw_bioio.py</code>: BioIO-based implementation for local files</li> <li><code>iw_ngff.py</code>: OME-NGFF/Zarr implementation using ome-zarr-py</li> <li><code>iw_blitz.py</code>: OMERO Blitz implementation for remote servers</li> </ul> <p>All implementations produce identical hashes for identical pixel data, conforming to the IMAGEWALK specification.</p>"},{"location":"#command-line-interface","title":"Command-Line Interface","text":""},{"location":"#biocode-generate-bioimage-fingerprint","title":"<code>biocode</code> - Generate Bioimage Fingerprint","text":"<p>Create comprehensive bioimage fingerprints with ISCC codes:</p> <pre><code>iscc-bio biocode INPUT [OPTIONS]\n\nOptions:\n  -o, --output-dir PATH    Save extracted view PNGs\n  -n, --max-views INTEGER  Maximum views per scene (default: 5)\n</code></pre>"},{"location":"#pixhash-normalized-pixel-hash","title":"<code>pixhash</code> - Normalized Pixel Hash","text":"<p>Generate reproducible SHA1 hashes over normalized pixel data:</p> <pre><code>iscc-bio pixhash INPUT [OPTIONS]\n\nOptions:\n  -s, --source [auto|bioio|omero|zarr]  Data source type\n  --host TEXT                           OMERO server hostname\n  --iid INTEGER                         OMERO image ID\n</code></pre>"},{"location":"#views-extract-representative-views","title":"<code>views</code> - Extract Representative Views","text":"<p>Extract intelligent 2D views for perceptual hashing:</p> <pre><code>iscc-bio views INPUT [OPTIONS]\n\nOptions:\n  -s, --strategies TEXT    View strategies (mip, best_focus, representative, composite)\n  -n, --max-views INTEGER  Maximum views to extract (default: 8)\n  -o, --output-dir PATH    Directory to save thumbnails\n  --host TEXT              OMERO server hostname\n  --iid INTEGER            OMERO image ID\n</code></pre>"},{"location":"#scenes-extract-scene-thumbnails","title":"<code>scenes</code> - Extract Scene Thumbnails","text":"<p>Extract thumbnails from all scenes in a multi-scene file:</p> <pre><code>iscc-bio scenes INPUT\n</code></pre>"},{"location":"#thumb-extract-thumbnail","title":"<code>thumb</code> - Extract Thumbnail","text":"<p>Extract a single representative thumbnail from a bioimage:</p> <pre><code>iscc-bio thumb INPUT\n</code></pre>"},{"location":"#python-api","title":"Python API","text":""},{"location":"#imagewalk-plane-iteration","title":"IMAGEWALK Plane Iteration","text":"<pre><code>from iscc_bio.imagewalk.iw_bioio import iter_planes_bioio\nfrom iscc_bio.imagewalk.iw_ngff import iter_planes_ngff\nfrom iscc_bio.imagewalk.iw_blitz import iter_planes_blitz\n\n# Iterate over planes using BioIO\nfor plane in iter_planes_bioio(\"image.czi\"):\n    print(f\"Scene {plane.scene_idx}, Z={plane.z_depth}, \"\n          f\"C={plane.c_channel}, T={plane.t_time}\")\n    print(f\"Shape: {plane.xy_array.shape}, dtype: {plane.xy_array.dtype}\")\n\n# Iterate over OME-Zarr planes\nfor plane in iter_planes_ngff(\"data.zarr\"):\n    # Process plane.xy_array (2D numpy array)\n    pass\n\n# Iterate over OMERO planes\nfrom omero.gateway import BlitzGateway\nconn = BlitzGateway(\"user\", \"pass\", host=\"omero.server.com\")\nconn.connect()\nimage = conn.getObject(\"Image\", 123)\n\nfor plane in iter_planes_blitz(image):\n    # Process plane.xy_array\n    pass\nconn.close()\n</code></pre>"},{"location":"#generate-biocode","title":"Generate Biocode","text":"<pre><code>from iscc_bio.biocode import generate_biocode, format_output\n\n# Generate bioimage fingerprints\nfingerprints = generate_biocode(\"image.nd2\", max_views=5)\n\n# Format output\noutput = format_output(fingerprints, \"image.nd2\")\nprint(output)\n</code></pre>"},{"location":"#pixel-hashing","title":"Pixel Hashing","text":"<pre><code>from iscc_bio.pixhash import pixhash_bioio, pixhash_zarr, pixhash_omero\n\n# Generate pixel hash (returns list of hashes, one per scene)\nhashes = pixhash_bioio(\"image.lif\")\nprint(hashes[0])  # Hash for first scene\n\n# OME-Zarr\nhashes = pixhash_zarr(\"data.zarr\")\n\n# OMERO\nhashes = pixhash_omero(\"omero.server.com\", image_id=123)\n</code></pre>"},{"location":"#supported-formats","title":"Supported Formats","text":"<p>Via BioIO plugin ecosystem:</p> <ul> <li>OME-TIFF/TIFF: Multi-page TIFF with OME-XML metadata</li> <li>OME-Zarr/NGFF: Next-generation file format</li> <li>OMERO: Remote server access via Blitz gateway</li> <li>CZI: Carl Zeiss Image format</li> <li>ND2: Nikon NIS-Elements format</li> <li>LIF: Leica Image File format</li> <li>DV: DeltaVision format</li> <li>BioFormats: 150+ formats via Bio-Formats Java library</li> </ul>"},{"location":"#development","title":"Development","text":""},{"location":"#setup-development-environment","title":"Setup Development Environment","text":"<pre><code># Clone repository\ngit clone https://github.com/bio-codes/iscc-bio.git\ncd iscc-bio\n\n# Install with all dependencies\nuv sync --extra all\n\n# Run CLI during development\nuv run iscc-bio --help\n</code></pre>"},{"location":"#development-commands","title":"Development Commands","text":"<p>This project uses poethepoet for task automation:</p> <pre><code># Format markdown files\nuv run poe format-md\n\n# Format code files\nuv run poe format-code\n\n# Build documentation\nuv run poe docs-build\n\n# Run all formatting and docs\nuv run poe all\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":""},{"location":"#core-modules","title":"Core Modules","text":"<ul> <li> <p><code>iscc_bio.imagewalk</code>: IMAGEWALK plane traversal implementations</p> <ul> <li><code>iw_bioio.py</code>: BioIO implementation</li> <li><code>iw_ngff.py</code>: OME-Zarr/NGFF implementation</li> <li><code>iw_blitz.py</code>: OMERO Blitz implementation</li> <li><code>models.py</code>: Plane data model</li> </ul> </li> <li> <p><code>iscc_bio.biocode</code>: ISCC bioimage fingerprint generation</p> </li> <li> <p><code>iscc_bio.pixhash</code>: Normalized pixel hashing across sources</p> </li> <li> <p><code>iscc_bio.views</code>: Intelligent view extraction strategies</p> </li> <li> <p><code>iscc_bio.cli</code>: Command-line interface</p> </li> </ul>"},{"location":"#design-principles","title":"Design Principles","text":"<ol> <li>Lazy Loading: Uses Dask arrays for memory-efficient processing of large images</li> <li>Format Agnostic: Identical processing logic across all formats via IMAGEWALK</li> <li>Deterministic: Reproducible hashes across platforms and formats</li> <li>Modular: Clean separation between traversal, canonicalization, and hashing</li> </ol>"},{"location":"#funding","title":"Funding","text":"<p>This work was supported through the Open Science Clusters\u2019 Action for Research and Society (OSCARS) European project under grant agreement N\u00ba101129751.</p> <p>See: BIO-CODES project (Enhancing AI-Readiness of Bioimaging Data with Content-Based Identifiers).</p>"},{"location":"#license","title":"License","text":"<p>Apache License 2.0 - See LICENSE file for details.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use iscc-bio in your research, please cite:</p> <pre><code>@software{iscc_bio,\n  title        = {bio-codes/iscc-bio: ISCC Processing for Bioimage Data},\n  author       = {Pan, Titusz},\n  year         = 2025,\n  url          = {https://github.com/bio-codes/iscc-bio},\n  note         = {Supported by OSCARS (Open Science Clusters' Action for Research and Society) under European Commission grant agreement N\u00ba101129751},\n  version      = {0.1.0}\n}\n</code></pre>"},{"location":"#related-projects","title":"Related Projects","text":"<ul> <li>iscc-sum - Fast ISCC Data-Code and Instance-Code hashing</li> <li>iscc-core - ISCC Core Algorithms</li> <li>BioIO - Bioimage reading library</li> <li>OME-Zarr - Next-generation file format implementation</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#010-unreleased","title":"[0.1.0] - Unreleased","text":""},{"location":"imagewalk/","title":"IMAGEWALK","text":""},{"location":"imagewalk/#imagewalk","title":"IMAGEWALK","text":"<p>Deterministic Traversal of Multi-Dimensional Bioimage Pixel Data</p> <p>Deterministic algorithm for traversing and canonicalizing pixel data from multi-dimensional bioimages to produce consistent, reproducible hash digests across platforms and file formats.</p>"},{"location":"imagewalk/#abstract","title":"Abstract","text":"<p>This specification defines a deterministic algorithm for traversing multi-dimensional bioimage data and converting it to canonical byte sequences. The algorithm ensures that identical pixel data produces identical hash outputs regardless of source format (OME-TIFF, OME-Zarr, OMERO, CZI, etc.) or storage platform. It handles common bioimage dimensions (T, C, Z, Y, X), supports multi-scene files, and provides a format-agnostic foundation for content-based identification of bioimaging data.</p>"},{"location":"imagewalk/#status","title":"Status","text":"<p>This specification is DRAFT as of 2025-10-03.</p> <p>OMERO Compatibility</p> <p>This specification is based on and compatible with OMERO server v5.29.2's internal pixel data canonicalization method for generating hashes at the scene/image level.</p>"},{"location":"imagewalk/#1-introduction","title":"1. Introduction","text":""},{"location":"imagewalk/#11-motivation","title":"1.1 Motivation","text":"<p>Bioimaging data exists in numerous formats with different internal storage layouts and dimension orders. Traditional format-specific hashing produces different results for semantically identical pixel data stored in different formats. This specification solves that problem by defining a canonical traversal and byte representation that is independent of storage format, enabling reproducible content-based identifiers for bioimage data.</p>"},{"location":"imagewalk/#12-scope","title":"1.2 Scope","text":"<p>This specification defines:</p> <p>IMAGEWALK Algorithm:</p> <ul> <li>Deterministic plane traversal order for multi-dimensional bioimage data</li> <li>Canonical byte representation for 2D pixel planes</li> <li>Handling of standard bioimage dimensions (T, C, Z, Y, X)</li> <li>Processing of multi-scene/multi-series files</li> </ul> <p>It does NOT cover:</p> <ul> <li>File format parsing, decoding, or storage APIs</li> <li>Hash algorithm selection or implementation details</li> <li>Pixel value transformations, rescaling, or normalization</li> <li>Metadata extraction, validation, or processing</li> <li>Image compression or encoding methods</li> </ul>"},{"location":"imagewalk/#13-notation-and-conventions","title":"1.3 Notation and Conventions","text":"<p>The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are interpreted as described in [RFC 2119] and [RFC 8174].</p>"},{"location":"imagewalk/#2-terminology","title":"2. Terminology","text":"<p>Bioimage : Multi-dimensional pixel array representing microscopy or other bioimaging data.</p> <p>Plane : A 2D array of pixels with dimensions Y (height) and X (width) at a specific combination of Z (depth), C (channel), and T (time) coordinates. Each plane contains pixel intensity values for a single channel at a single focal depth and timepoint.</p> <p>Dimension : An axis of the multi-dimensional array. Standard bioimage dimensions are:</p> <ul> <li>T (Time): Temporal dimension for time-series data</li> <li>C (Channel): Spectral or fluorescence channel dimension representing a specific imaging modality (e.g.,     GFP, DAPI, brightfield). A channel consists of all planes sharing the same C index across different Z and T     coordinates</li> <li>Z (Depth): Z-stack or focal plane dimension</li> <li>Y (Height): Vertical spatial dimension</li> <li>X (Width): Horizontal spatial dimension</li> </ul> <p>Scene/Series : Independent image within a multi-image file. Each scene/series has its own dimensional structure and is processed independently.</p> <p>Canonical Bytes : Standardized byte representation of pixel data ensuring deterministic, cross-platform reproducible output.</p> <p>Row-Major Order : Linear ordering where rightmost indices vary fastest (C-order). For 2D plane (Y, X), pixels are ordered: row 0 (all X), row 1 (all X), etc.</p> <p>Big-Endian : Byte order where the most significant byte is stored at the lowest memory address (network byte order).</p>"},{"location":"imagewalk/#3-algorithm-overview","title":"3. Algorithm Overview","text":"<pre><code>flowchart LR\n    A[Bioimage Input] --&gt; B{For Each&lt;br/&gt;Scene}\n    B --&gt; C[Initialize:&lt;br/&gt;\u2022 Get T,C,Z,Y,X&lt;br/&gt;\u2022 Create Hash]\n\n    C --&gt; D{For Each Plane&lt;br/&gt;Z\u2192C\u2192T}\n    D --&gt; E[Process:&lt;br/&gt;\u2022 Extract 2D&lt;br/&gt;\u2022 Flatten Y,X&lt;br/&gt;\u2022 Big-Endian&lt;br/&gt;\u2022 Update Hash]\n\n    E --&gt; D\n    D --&gt;|All Planes| F[Finalize Hash]\n    F --&gt; B\n    B --&gt;|All Scenes| G[Return Hashes]\n\n    style E fill:#e8f5e9</code></pre> <p>The algorithm processes bioimages deterministically by:</p> <ol> <li>Processing each scene/series independently</li> <li>Traversing planes in Z-&gt;C-&gt;T order</li> <li>Converting each plane to canonical bytes</li> <li>Producing one hash per scene/series</li> </ol>"},{"location":"imagewalk/#4-core-algorithm-specification","title":"4. Core Algorithm Specification","text":""},{"location":"imagewalk/#41-multi-scene-processing","title":"4.1 Multi-Scene Processing","text":"<p>For files containing multiple scenes/series, implementations MUST:</p> <ol> <li>Process each scene/series independently - Initialize a new hash processor for each scene</li> <li>Maintain scene order - Process scenes in ascending numerical order (0, 1, 2, ...)</li> <li>Generate separate hashes - Produce one hash output per scene/series</li> <li>Return ordered list - Return hashes as a list in scene/series order</li> </ol> <p>Note</p> <p>Single-scene files produce a single-element list. Empty files or files with no accessible scenes return an empty list.</p>"},{"location":"imagewalk/#42-dimension-identification","title":"4.2 Dimension Identification","text":"<p>For each scene/series, implementations MUST:</p> <ol> <li>Identify present dimensions - Determine which dimensions (T, C, Z, Y, X) exist in the data</li> <li>Determine dimension sizes - Get the size of each dimension</li> <li>Map dimension positions - Identify where each dimension appears in the data structure</li> </ol> <p>The Y and X dimensions MUST be present in all bioimages. The T, C, and Z dimensions are OPTIONAL.</p> <p>When a dimension is absent:</p> <ul> <li>Treat its size as 1</li> <li>Skip the corresponding loop in traversal</li> <li>Do not include it in dimension ordering</li> </ul>"},{"location":"imagewalk/#43-plane-traversal-order","title":"4.3 Plane Traversal Order","text":"<p>Quick Reference</p> <p>Traverse planes in Z\u2192C\u2192T order: outermost Z, middle C, innermost T Each plane is a 2D pixel array for one channel at one Z-position and timepoint</p> <p>Implementations MUST traverse planes using nested loops in this exact order:</p> <ol> <li>Outermost loop: Z dimension - Iterate from 0 to size_z - 1</li> <li>Middle loop: C dimension - Iterate from 0 to size_c - 1</li> <li>Innermost loop: T dimension - Iterate from 0 to size_t - 1</li> </ol> <p>For each combination of coordinates (z, c, t), extract the 2D plane at position (z, c, t, :, :). This plane contains pixel intensity values for channel c at z-position z and timepoint t.</p>"},{"location":"imagewalk/#example-traversal","title":"Example Traversal","text":"<p>For an image with size_z=2, size_c=3, size_t=2, planes are processed in this order:</p> <pre><code>Plane 1:  z=0, c=0, t=0\nPlane 2:  z=0, c=0, t=1\nPlane 3:  z=0, c=1, t=0\nPlane 4:  z=0, c=1, t=1\nPlane 5:  z=0, c=2, t=0\nPlane 6:  z=0, c=2, t=1\nPlane 7:  z=1, c=0, t=0\nPlane 8:  z=1, c=0, t=1\nPlane 9:  z=1, c=1, t=0\nPlane 10: z=1, c=1, t=1\nPlane 11: z=1, c=2, t=0\nPlane 12: z=1, c=2, t=1\n</code></pre> <p>Total planes: 2 \u00d7 3 \u00d7 2 = 12</p> <p>Warning</p> <p>The traversal order is Z\u2192C\u2192T, not the dimension storage order. This order is independent of how the source format stores pixel data internally.</p>"},{"location":"imagewalk/#44-canonical-byte-conversion","title":"4.4 Canonical Byte Conversion","text":"<p>Quick Reference</p> <p>Flatten 2D plane in row-major order (Y then X) and encode as big-endian bytes</p> <p>For each extracted 2D plane, implementations MUST apply the following conversion:</p>"},{"location":"imagewalk/#step-1-validate-plane-dimensionality","title":"Step 1: Validate Plane Dimensionality","text":"<p>The plane MUST have exactly 2 dimensions (Y, X). If the extracted plane has singleton dimensions, they MUST be squeezed out before conversion.</p>"},{"location":"imagewalk/#step-2-flatten-in-row-major-order","title":"Step 2: Flatten in Row-Major Order","text":"<p>Flatten the 2D array using row-major (C-order) traversal:</p> <ul> <li>Y dimension varies slowest (outer loop)</li> <li>X dimension varies fastest (inner loop)</li> <li>Linearization order: (0,0), (0,1), ..., (0,X-1), (1,0), (1,1), ..., (Y-1,X-1)</li> </ul> <p>This produces a 1D array of size Y \u00d7 X.</p>"},{"location":"imagewalk/#step-3-encode-as-big-endian-bytes","title":"Step 3: Encode as Big-Endian Bytes","text":"<p>Convert pixel values to big-endian byte sequences:</p> <ul> <li>For single-byte types (int8, uint8): Each pixel becomes 1 byte</li> <li>For multi-byte types (int16, uint16, int32, uint32, float32, float64):<ul> <li>Each pixel is encoded in big-endian byte order</li> <li>Most significant byte appears first in the byte sequence</li> </ul> </li> </ul> <p>Rationale: Big-endian encoding ensures cross-platform reproducibility regardless of host system byte order.</p>"},{"location":"imagewalk/#example-22-uint16-plane","title":"Example: 2\u00d72 uint16 Plane","text":"<pre><code>Input plane (row-major notation):\n  [[256, 512],\n   [768, 1024]]\n\nAfter flattening: [256, 512, 768, 1024]\n\nCanonical bytes (big-endian uint16):\n  0x01 0x00  0x02 0x00  0x03 0x00  0x04 0x00\n\nTotal: 8 bytes (4 pixels \u00d7 2 bytes per pixel)\n</code></pre>"},{"location":"imagewalk/#understanding-planes-in-multi-channel-images","title":"Understanding Planes in Multi-Channel Images","text":"<p>For a 3-channel RGB image with dimensions C=3, Y=512, X=512:</p> <ul> <li>Plane at (z=0, c=0, t=0): 512\u00d7512 2D array of RED channel intensities</li> <li>Plane at (z=0, c=1, t=0): 512\u00d7512 2D array of GREEN channel intensities</li> <li>Plane at (z=0, c=2, t=0): 512\u00d7512 2D array of BLUE channel intensities</li> </ul> <p>Each plane is processed separately to create its canonical byte sequence.</p>"},{"location":"imagewalk/#45-hash-processing","title":"4.5 Hash Processing","text":"<p>Implementations MUST follow this hash processing protocol:</p> <ol> <li>Initialize processor - Create a new hash processor instance at the start of each scene/series</li> <li>Incremental updates - Feed canonical bytes from each plane to the hash processor in traversal order</li> <li>Finalize hash - After all planes are processed, finalize and extract the hash for that scene/series</li> <li>Collect results - Append the scene hash to the output list</li> </ol> <p>Note</p> <p>This specification does not mandate a specific hash algorithm. The canonical byte sequence produced by IMAGEWALK can be used with any hash function or content identification scheme. Reference implementations use ISCC-SUM (iscc_sum.IsccSumProcessor) for bioimage fingerprinting.</p>"},{"location":"imagewalk/#5-implementation-examples","title":"5. Implementation Examples","text":""},{"location":"imagewalk/#51-simple-2d-grayscale-image","title":"5.1 Simple 2D Grayscale Image","text":"<pre><code>Structure:\n  Dimensions: Y=512, X=512\n  Data type: uint8\n  Scenes: 1\n\nProcessing:\n  - Dimension sizes: size_z=1, size_c=1, size_t=1\n  - Total planes: 1 \u00d7 1 \u00d7 1 = 1\n  - Single plane at (0, 0, 0, :, :)\n  - Flatten: 512 \u00d7 512 = 262,144 pixels\n  - Convert: 262,144 bytes (uint8 is single byte)\n  - Feed to hash processor\n  - Finalize hash\n\nOutput:\n  - Single hash string\n</code></pre>"},{"location":"imagewalk/#52-multi-channel-rgb-time-series","title":"5.2 Multi-Channel RGB Time Series","text":"<pre><code>Structure:\n  Dimensions: T=10, C=3, Y=256, X=256\n  Data type: uint16\n  Scenes: 1\n\nProcessing:\n  - Dimension sizes: size_z=1, size_c=3, size_t=10\n  - Total planes: 1 \u00d7 3 \u00d7 10 = 30\n  - Traversal order: z=0, c=0\u20132, t=0\u20139\n  - Each plane: 256 \u00d7 256 = 65,536 pixels\n  - Each plane: 131,072 bytes (65,536 \u00d7 2 bytes)\n  - Feed 30 planes to hash processor\n  - Finalize hash\n\nOutput:\n  - Single hash string\n</code></pre>"},{"location":"imagewalk/#53-multi-scene-confocal-z-stack","title":"5.3 Multi-Scene Confocal Z-Stack","text":"<pre><code>Structure:\n  Dimensions (per scene): Z=20, C=2, Y=1024, X=1024\n  Data type: uint16\n  Scenes: 3\n\nProcessing (per scene):\n  - Dimension sizes: size_z=20, size_c=2, size_t=1\n  - Total planes: 20 \u00d7 2 \u00d7 1 = 40\n  - Traversal order: z=0\u201319, c=0\u20131, t=0\n  - Each plane: 1024 \u00d7 1024 = 1,048,576 pixels\n  - Each plane: 2,097,152 bytes (1,048,576 \u00d7 2 bytes)\n  - Feed 40 planes to hash processor\n  - Finalize hash\n  - Repeat for scenes 1 and 2\n\nOutput:\n  - List of 3 hash strings\n</code></pre>"},{"location":"imagewalk/#6-implementation-guidance","title":"6. Implementation Guidance","text":""},{"location":"imagewalk/#61-memory-efficiency","title":"6.1 Memory Efficiency","text":"<p>Implementations SHOULD:</p> <ul> <li>Process planes one at a time without loading entire datasets into memory</li> <li>Use streaming/incremental hash processors that accept data in chunks</li> <li>Leverage lazy evaluation and delayed loading when available</li> <li>Consider resolution pyramids for large images (use appropriate resolution level)</li> </ul> <p>Tip</p> <p>Many bioimage formats support chunked/tiled storage. Implementations can read plane data tile-by-tile and feed bytes incrementally to the hash processor.</p>"},{"location":"imagewalk/#62-data-type-support","title":"6.2 Data Type Support","text":"<p>Implementations MUST support the following pixel data types:</p> <ul> <li>Unsigned integers: uint8, uint16, uint32</li> <li>Signed integers: int8, int16, int32</li> <li>Floating point: float32 (single precision), float64 (double precision)</li> </ul> <p>Implementations MAY support additional types (e.g., uint64, int64, complex64, complex128) but MUST document their byte encoding conventions.</p>"},{"location":"imagewalk/#63-performance-optimization","title":"6.3 Performance Optimization","text":"<p>Implementations MAY:</p> <ul> <li>Use vectorized operations for byte-order conversion</li> <li>Utilize native library functions (e.g., NumPy's <code>tobytes()</code> with dtype specification)</li> <li>Parallelize processing of independent scenes/series</li> <li>Cache dimension metadata to avoid repeated queries</li> </ul> <p>Warning</p> <p>When parallelizing scene processing, ensure the output hash list maintains scene order. Hashes must be assembled in ascending scene index order (0, 1, 2, ...).</p>"},{"location":"imagewalk/#64-error-handling","title":"6.4 Error Handling","text":"<p>Implementations MUST:</p> <ul> <li>Validate that extracted planes are 2D before canonicalization</li> <li>Provide clear error messages for unsupported data types</li> <li>Handle missing or inaccessible scenes gracefully (skip and log warning)</li> <li>Detect and report dimension mismatches or malformed data</li> </ul> <p>Implementations SHOULD:</p> <ul> <li>Validate dimension sizes are positive integers</li> <li>Check for reasonable dimension sizes to prevent resource exhaustion</li> <li>Warn when processing extremely large images that may cause memory issues</li> </ul>"},{"location":"imagewalk/#7-test-vectors","title":"7. Test Vectors","text":"<p>Implementations MUST produce correct outputs for these test cases:</p>"},{"location":"imagewalk/#71-canonical-byte-conversion-tests","title":"7.1 Canonical Byte Conversion Tests","text":""},{"location":"imagewalk/#test-case-1-tiny-uint8-plane","title":"Test Case 1: Tiny uint8 Plane","text":"<p>Input:</p> <pre><code>Dimensions: Y=2, X=2\nData type: uint8\nValues (row-major): [[1, 2], [3, 4]]\n</code></pre> <p>Expected canonical bytes:</p> <pre><code>0x01 0x02 0x03 0x04\n</code></pre> <p>Explanation: Single-byte type, flattened row-major: row 0 (1, 2), row 1 (3, 4)</p>"},{"location":"imagewalk/#test-case-2-tiny-uint16-plane","title":"Test Case 2: Tiny uint16 Plane","text":"<p>Input:</p> <pre><code>Dimensions: Y=2, X=2\nData type: uint16\nValues (row-major): [[256, 512], [768, 1024]]\n</code></pre> <p>Expected canonical bytes:</p> <pre><code>0x01 0x00  0x02 0x00  0x03 0x00  0x04 0x00\n</code></pre> <p>Explanation: Big-endian encoding. 256 = 0x0100 \u2192 0x01 0x00 (MSB first)</p>"},{"location":"imagewalk/#test-case-3-float32-plane","title":"Test Case 3: Float32 Plane","text":"<p>Input:</p> <pre><code>Dimensions: Y=1, X=2\nData type: float32\nValues: [[1.0, 2.0]]\n</code></pre> <p>Expected canonical bytes:</p> <pre><code>0x3F 0x80 0x00 0x00  0x40 0x00 0x00 0x00\n</code></pre> <p>Explanation: IEEE 754 single precision, big-endian. 1.0 = 0x3F800000, 2.0 = 0x40000000</p>"},{"location":"imagewalk/#72-traversal-order-tests","title":"7.2 Traversal Order Tests","text":""},{"location":"imagewalk/#test-case-4-multi-dimensional-traversal","title":"Test Case 4: Multi-Dimensional Traversal","text":"<p>Input:</p> <pre><code>Dimensions: T=2, C=2, Z=2, Y=1, X=1\nData type: uint8\nValues: Single pixel per plane, all pixels have value 0xFF\n</code></pre> <p>Expected plane extraction order:</p> <pre><code>1. z=0, c=0, t=0\n2. z=0, c=0, t=1\n3. z=0, c=1, t=0\n4. z=0, c=1, t=1\n5. z=1, c=0, t=0\n6. z=1, c=0, t=1\n7. z=1, c=1, t=0\n8. z=1, c=1, t=1\n</code></pre> <p>Expected canonical bytes:</p> <pre><code>0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF\n</code></pre> <p>Total bytes: 8 (one per plane)</p>"},{"location":"imagewalk/#73-multi-scene-tests","title":"7.3 Multi-Scene Tests","text":""},{"location":"imagewalk/#test-case-5-two-scene-file","title":"Test Case 5: Two-Scene File","text":"<p>Input:</p> <pre><code>Scene 0:\n  Dimensions: Y=1, X=1\n  Data type: uint8\n  Value: 0x01\n\nScene 1:\n  Dimensions: Y=1, X=1\n  Data type: uint8\n  Value: 0x02\n</code></pre> <p>Expected output:</p> <pre><code>- Hash from canonical bytes 0x01\n- Hash from canonical bytes 0x02\n</code></pre> <p>Constraint: Output must be a list of exactly 2 hashes in scene order</p>"},{"location":"imagewalk/#8-conformance","title":"8. Conformance","text":"<p>An implementation conforms to this specification if it satisfies all of the following:</p> <ol> <li> <p>Deterministic output: Produces identical hash sequences for identical pixel data across different source     formats and platforms</p> </li> <li> <p>Scene ordering: Processes scenes/series in ascending numerical order (0, 1, 2, ...) and returns hashes in     the same order</p> </li> <li> <p>Plane traversal: Iterates planes in Z\u2192C\u2192T order (outermost to innermost)</p> </li> <li> <p>Row-major flattening: Flattens 2D planes in row-major order (Y varies slowly, X varies fast)</p> </li> <li> <p>Big-endian encoding: Encodes multi-byte pixel values in big-endian byte order</p> </li> <li> <p>Data type support: Correctly handles all required data types (uint8, uint16, uint32, int8, int16, int32,     float32, float64)</p> </li> <li> <p>Test vectors: Produces correct canonical byte sequences for all test vectors in Section 7</p> </li> </ol>"},{"location":"imagewalk/#9-extensibility","title":"9. Extensibility","text":""},{"location":"imagewalk/#91-custom-hash-algorithms","title":"9.1 Custom Hash Algorithms","text":"<p>This specification defines the canonical byte sequence generation but does not mandate a specific hash algorithm. Implementations MAY use:</p> <ul> <li>Cryptographic hashes (SHA-256, BLAKE3)</li> <li>Perceptual hashes (pHash, ISCC)</li> <li>Content-defined chunking hashes (FastCDC + SHA)</li> <li>Rolling hashes for incremental processing</li> </ul> <p>The canonical byte sequence ensures reproducibility regardless of hash algorithm choice.</p>"},{"location":"imagewalk/#92-additional-dimensions","title":"9.2 Additional Dimensions","text":"<p>Future extensions MAY define handling for additional dimensions beyond T, C, Z, Y, X. If extended:</p> <ul> <li>The specification MUST define the position of new dimensions in traversal order</li> <li>The specification MUST maintain deterministic, reproducible ordering</li> <li>Backward compatibility SHOULD be preserved for standard 5D data</li> </ul>"},{"location":"imagewalk/#93-metadata-integration","title":"9.3 Metadata Integration","text":"<p>Implementations MAY incorporate metadata (pixel size, channel names, acquisition parameters) into hash generation. If metadata is included:</p> <ul> <li>The specification MUST define canonical metadata ordering and encoding</li> <li>Metadata processing MUST be deterministic and format-agnostic</li> <li>Pixel data and metadata hashing SHOULD be clearly separable</li> </ul>"},{"location":"imagewalk/#10-references","title":"10. References","text":""},{"location":"imagewalk/#normative","title":"Normative","text":"<ul> <li>RFC 2119: Key words for use in RFCs to Indicate Requirement Levels</li> <li>RFC 8174: Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</li> <li>IEEE 754: Standard for Floating-Point Arithmetic</li> </ul>"},{"location":"imagewalk/#informative","title":"Informative","text":"<ul> <li>OME-NGFF Specification (OME-Zarr format)</li> <li>OMERO Data Model Documentation</li> <li>ISO 24138:2024 - International Standard Content Code</li> <li>BioFormats Supported Formats Documentation</li> </ul>"}]}